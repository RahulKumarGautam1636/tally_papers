vid - 2: -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2) Installation types of dependencies -  There are two types of methods by which we can install the dependencies.
   i) Dev dependency - we install using this method when we need a dependency only in development phase. ex- >> npm install -D pagege-name
  ii) Normal dependency - it is normal way of installing dependencies. ex- >> npm install pagege-name

3) Caret up (^) vs Tilde in pakage.json - The name of installed dependencies have Caret up or tilde sign in from of them. The caret sign implies that if any minor update is available for that dependency then npm
                                          will automatically update the dependency where Tilde sign will update both minor and major versions. It is safe to keep caret sign because any major update in dependency
                                          can break it and also the app. update from version 1.2 to 1.3 is minor update while update from 1.2 to 2.0 is taken as major update. no sign will never update versions.

4) pakage.json vs pakage.lock.json - pakage.lock.json keeps track of versions of each pakage present in node modules. The dependencies we install have their own dependencies and that also can have their own
                                     dependencies. pakage.lock.json keeps track of exact versions of all of them where pakage.json keeps approximate version info of all the major dependencies we installed.

5) Bundlers - Bundlers are pakages that are used to create smoother development experience. it performes following jobs listed below.
              1) Dev Build - Prepare a production ready optimised build for deployment on servers.
             ii) Local server - creates a local server to mimic the online server for development.

vid - 3: -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1) JSX - JSX is not html it is a javascript object that is why it's attributes are different than normal html attributes. Babel transpiles JSX into real html that is present in root.render() function.
         >> const obj = <h1> Hello world </h1>;
         >> console.log(obj)                           // logs a javascript object.
2) Functional components  - In react Functional components are special functions that returns JSX elements. We can not pass JSX elements directly to root.render(). We need a Functional components that returns JSX,
                            that can be passed into root.render() to get rendered in DOM tree.
                            >> root.render(<h1> Hello world </h1>)                     // will throw error.
                            >> root.render( <Heading/> )                               // will work fine.
3) * What is component composition - Nesting two or more components in each other is called component composition.

4) * Cross site scripting attack - In React sometime we call an API and pass the returned result into the JSX, since JSX is a javascript object that means passed result will be executed as javascript. This gives
                                   attackers a chance to send and run some malicious code with API results. This type of attack is called Cross site scripting attack. JSX automatically takes care of this problem and 
                                   sanitises the recieved result before running it hence we don't need to worry about it.

vid - 4: Food ordering app ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1) *Config driven UI - The UI that receives it's styles and data dynamically from APIs or backend is called Config driven UI. Google - Config-driven UI is a technique that allows you to create user interfaces
                       based on a configuration file, such as JSON, or a TypeScript file that defines the layout and content of the UI components.

2) Keys in React - First we need to know why we use keys. Suppose <ul> has multiple lists items that is generated by mapping <li> elements with some array of data. when any rerender is happens for any reason like
                   adding / removing new item in the list then during rendered react tries to check if current updated items are same as previous items or not. If yes them react does not rerender the previously
                   existing items and only adds / removes / updates the new item in rerender that brings good amount of optimisation by blocking unessesay rerenders. The Keys are given to each loop created element
                   to identify it during rerenders to decide whether to rerender them or not. if we don't give any keys to them whenever a rerender happens them whole list is rendered because react cannot find 
                   or identify the item that is only need to update.

                   ***Index as keys - React docs - "You might be tempted to Use of item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in
                                      which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs."

                   ***Generate keys - do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated
                                      every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.

                   ***Keys must not change - Whatever you use just remember Keys must not change during renders that defeats their purpose.

vid - 5: Food ordering app ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------                    

1) Reconcilliation or Diff Algorithm - React uses Diff Algorithm to identify changes in elements using key property to only update them, this is called Reconcilliation in react.                               

***Why React is fast - React has virtual DOM concept. The react fiber, react's new Reconcilliation Algorithm compares the two (old and updated) virtual DOMs to find the difference
                       and updates the only portion of DOM that are required to be changed. this is why react is so fast in DOM manipulation.
     
2) useEffect - 1) A Hook from react to imitate life-cycle methods of a component. Takes two arguments, i) A callback function and ii) Optionsl dependency array. callback is executed when
                  values in dependency array are changed. Explanation of render cycles are given below.

                  i) with no dependency array - useEffect will run with every rerender. never do this, it can put the component in infinite loop of rerendering.
                 ii) with empty dependency array - useEffect runs only once and after the component is fully loaded on DOM.
                iii) with filled dependency array - useEffect runs each time when values passed in dependency array changes.
                  
Episode - 8: Class components ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------                    

1) The render cycle of Class components - React has two main phases for component handling. 1) Render phase - The phase in component is rendered on dom with initial state values. 2) Commit phase- It is phase
                                          in which all initial update in component is performed hence the componentDidMount falls in this phase. React first performes Render phases for all the components and
                                          it's childs then after that it performes the Commit phases for all the components and it's childs.

                                          1) For a single component first constructor method > render method > componentDidMount methods are called in this sequence to completely render the component.

                                          2) For nested component of given structure, following calling sequece is used. Notice that the childs componentDidMount methods are called in end.

                                             class Prent extends React.component {        
                                                constructor() {                       - Prent constructor 
                                                  super(props)                        - Prent render
                                                                                      
                                                }                                     - First child constructor
                                                                                      - First child render
                                                render() {                        
                                                  <div>                               - Second child constructor
                                                    <Card />                          - Second child render
                                                    <Card />
                                                  </div>                              - First child componentDidMount
                                                }                                     - Second child componentDidMount
                                             }

                                             We can see that child componentDidMount is batched togather and called later togather in their sequece. React does it for optimisation to render something
                                             first and update it later.

    ***Batching of Commit phase - React Batches (groups) the Commit phase (componentDidMount) of all components and it's childs and performes them in their respective sequece after the render phase is finished.

 Episode - 9: Optimize the app -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------                    

 1) Make reusable components and hooks.
 2) Chunking, Code Splitting, Dynamic Bundling or Lazy loading - When use lazy loading, the bundler creates seperate js file for that component and it is loaded in browser when user navigates to it's page. This is also
                                                                 Called Chunking, Code Splitting or Dynamic Bundling. This prevents our app to load unwanted code on browser which makes our app light and fast.

                                                                 Ex - Suppose we have a section in our app that is to order grocerries but our app's main function is to order foods. So here we can lazy load the grocery
                                                                      section and it's components. Initially our app will have not grocery related code but when user click grocery link then we load the seperate grocery
                                                                      js code chunk on browser. This will make our initial app intact from grocery code preventing overload on browser.

                                                                      import { lazy } from "react";

                                                                      const Grocery = lazy(() => import('*./components/Grocery'));

                                                                      in App.js use as 

                                                                      <Suspence fallback={<Spinner/>}>              // must use a loading screen to show during api call to get related js code, otherwise it will show error.
                                                                        <Grocery/>
                                                                      </Suspence>

Episode - 9: Data is new Oil -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------                    

        1) Context API - An API given by react to access data from anywhere in the app avoiding prop drilling. See how to use it from example. 
                         Or in simple words it creates a room for creating global states that can be read write from anywhere in the app.

                         1) Create Context with initial state / data and export it.

                            import { createContext } from 'react';

                            const UserContext = createContext({
                              UserName: 'Default User',
                              isLoggedIn: false
                            })   

                            export default UserContext;

                          2) This is how to read write it from component.

                             *** First go to that component and wrap it with UserContext.Provider like this.

                                const [login, setLogin] = useState({ login: true, userName: 'Rahul' })            // set a local state to modify UserContext data.

                                <UserContext.Provider value={{ isLoggedIn: true, UserName: 'Rahul', setUserName: setUserName }}>         // here value is new value given to UserContext. we can manipulate it from here and all the app will recieve the changes.
                                  <Header />                                                                                             // we also passing setUserName that can change values. we can access it from whole app and change UserContext values from there.
                                </UserContext.Provider>

                            *** Same UserContext nested with different values. Data can be overriden for other components by renesting the context with provider.

                                <UserContext.Provider value={{ isLoggedIn: true, UserName: 'Rahul', setUserName: setUserName }}>         // here value is new value given to UserContext. we can manipulate it from here and all the app will recieve the changes.
                                  <Header />                          // Header will receive UserName Rahul.
                                   <UserContext.Provider value={{ isLoggedIn: true, UserName: 'Manish', setUserName: setUserName }}> 
                                    <Home />                          // Home will receive UserName Manish.
                                   </UserContext.Provider>                                                                                           // we also passing setUserName that can change values. we can access it from whole app and change UserContext values from there.
                                </UserContext.Provider>
                                  

                             
                          2) This is how to read write it from wrapped component's Nested child component.

                             import UserContext from './utils/UserContext';
                             import useContext from 'react';

                             const { UserName, isLoggedIn, setUserName } = useContext(UserContext);           // we can now access value and setUserName to read and manipulate UserContext from this component.

                             <h1>{UserName}</h1>
                             <input onChange={() => setUserName(pre => ({ ...pre, isLoggedIn: false, UserName: '' }))};

                          3) Accessing contexts in Class components. We can't use useContext in class  components hence we need to use <ContextName.Consumer></ContextName.Consumer> component to access the context data.

                              <UserContext.Consumer>                        // <ContextName.Consumer> is a component, all the components nested inside it will recieve the context data. multiple nesting is also allowed.
                                {({ UserName }) => (                        // It takes a callback function in which we get context data as parameter.
                                  <h1 class='user-name'>{ UserName }</h1>                        
                                )}
                              </UserContext.Consumer>  